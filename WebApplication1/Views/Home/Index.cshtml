@{
    ViewData["Title"] = "Home Page1";
}
<div class="text-center">
    <h1 class="display-4">Welcome Hot Reload</h1>
    <p>Learn about <a href="https://docs.microsoft.com/aspnet/core">building Web apps with ASP.NET Core</a>.</p>
   
    <div class="row">
        <div class="col-4 bg-white text-dark">
            <div id="here_table"></div>
        </div>
        <div class="col-8 bg-gray text-dark">
            <div id="my_dataviz"></div>
        </div>
    </div>
    </div>
@section Scripts
{
    <style>
    
    .links line {
      stroke: #999;
      stroke-opacity: 0.6;
    }
    
    .nodes circle {
      stroke: #fff;
      stroke-width: 1.5px;
    }
    
    text {
      font-family: sans-serif;
      font-size: 10px;
    }
    
    </style>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="js/labeler.js"></script>
    <script>
        
// set the dimensions and margins of the graph
  const margin = {top: 20, right: 20, bottom: 20, left: 50};
  var labelArray = [], anchorArray = [];
  width = 800 - margin.left - margin.right;
  height = 800 - margin.top - margin.bottom;

// append the svg object to the body of the page
var svg = d3.select("#my_dataviz")
.append("svg")
  .attr("width", width + margin.left + margin.right)
  .attr("height", height + margin.top + margin.bottom)
.append("g")
  .attr("transform",
        "translate(" + margin.left + "," + margin.top + ")");


d3.json("/home/data", function(json) {
    
    var nodes=json.network.nodes;
    var xcoord =[];
    var ycoord=[]
    let nodescount =nodes.length;
    nodes.forEach(function(nodes){
        xcoord.push(parseFloat(nodes.coordinate.x));
        ycoord.push(parseFloat(nodes.coordinate.y));
    });
    var maxx=Math.max.apply(Math, xcoord);
    let minx=Math.min.apply(Math, xcoord);    
    let maxy=Math.max.apply(Math, ycoord);
    let miny=Math.min.apply(Math, ycoord);
        
    var  linearScaleX = d3.scaleLinear()
        .domain([minx, maxx])
        .range([0, 600]);
    var  linearScaleY = d3.scaleLinear()
          .domain([miny, maxy])
          .range([0, 600]);
    // Initialize the links
   const link = svg
          .append("g")
          .attr("class", "line")
          .selectAll("g")
          .data(json.network.links)
          .enter().append("g")
  
  
   const line= link.append("line")
          .attr("x1",d=> linearScaleX(d.firstNode.coordinate.x))
          .attr("y1",d=> linearScaleY(d.firstNode.coordinate.y))
          .attr("x2",d=> linearScaleX(d.secondNode.coordinate.x))
          .attr("y2",d=> linearScaleY(d.secondNode.coordinate.y))
          .style("stroke", function(d) {
                          if (d.linkType ==3) {
                            return "blue";
                          } else if (d.linkType ==1) {
                            return "lightblue";
                          }               
                        });
  function tomasz(d) {
  $('#here_table').empty();
  var results=[];
    results=json.linksresults.filter(obj => obj.link.name === d.name);  
    var m=results.length;
    
    var table = $('<table class="table table-striped"></table>');
    //var header = $('<th></th>');
    var headercol1=$('<th><th>').text('flow');
    var headercol2=$('<th><th>').text('velocity');
    table.append('<th><tr><td>TimeStep</td><td>frictionfactor</td><td>Flow</td><td>Velocity</td></tr></th>');
    //table.append(headercol2);
    //table.append(header);
    for (n = 0;n<m;n++){
        var row=$('<tr><td>'+results[n].step.step+'</td><td>'+(Math.round(results[n].frictionfactor* 10000) / 10000).toFixed(4)+'</td><td>'+(Math.round(results[n].flow * 10000) / 10000).toFixed(4)+'</td><td>'+(Math.round(results[n].velocity * 10000) / 10000).toFixed(4)+'</td></tr>');
        table.append(row);
        //row.append(row1);
        }
    $('#here_table').append(table);
  }
 
  const lableslink = link.append("text")
            .text(d=> d.name)
            .attr('x',d=> linearScaleX((d.firstNode.coordinate.x+d.secondNode.coordinate.x)/2)+6)
            .attr('y', d=> linearScaleY((d.firstNode.coordinate.y+d.secondNode.coordinate.y)/2)+6)
            .attr('r',d => {
                          labelArray.push({x: linearScaleX((d.firstNode.coordinate.x+d.secondNode.coordinate.x)/2), y: linearScaleY((d.firstNode.coordinate.y+d.secondNode.coordinate.y)/2), name: d.name, width: 0.0, height: 0.0});
                          anchorArray.push({x: linearScaleX((d.firstNode.coordinate.x+d.secondNode.coordinate.x)/2), y:linearScaleY((d.firstNode.coordinate.y+d.secondNode.coordinate.y)/2), r: 4});
                          
              })
            .style("fill","red")
            .on("click",d=> tomasz(d));
  

  
      var node = svg.append("g")
       .attr("class", "nodes")
      .selectAll("g")
      .data(nodes)
      .enter().append("g")

    
 const circle = node.append("circle") //   .selectAll("circle")    
      .attr("cx",d=> linearScaleX(d.coordinate.x))
      .attr("cy",d=> linearScaleY(d.coordinate.y))
      .attr("r", 2)
      .style("fill", "#69b3a2");
   d3.labeler()
            .label(labelArray)
            .anchor(anchorArray)
            .width(width)
            .height(height)
            .start(2000);
   redrawLabels();
    function redrawLabels(){
           lableslink
             .transition()
             .duration(1500)
             .attr("x",(d) => d.x)
             .attr("y",(d) => d.y);
   
           
         }
  function tomasz1(d) {
  $('#here_table').empty();
      var results=[];
     results=json.nodesresults.filter(obj => obj.name === d.name);  
     var m=results.length;
     var table = $('<table class="table table-striped"></table>');
         //var header = $('<th></th>');
         var headercol1=$('<th><th>').text('flow');
         var headercol2=$('<th><th>').text('velocity');
         table.append('<th><tr><td>TimeStep</td><td>Head</td><td>Demand</td><td>Pressure</td></tr></th>');
         //table.append(headercol2);
         //table.append(header);
         for (n = 0;n<m;n++){
             var row=$('<tr><td>'+results[n].timestep.step+'</td><td>'+(Math.round(results[n].head * 10000) / 10000).toFixed(4)+'</td><td>'+(Math.round(results[n].demand * 10000) / 10000).toFixed(4)+'</td><td>'+(Math.round(results[n].pressure * 10000) / 10000).toFixed(4)+'</td></tr>');
             table.append(row);
             //row.append(row1);
             }
         $('#here_table').append(table);
  }
  const lables = node.append("text")
          .text(d=> d.name)
          .attr('x',d=> linearScaleX(d.coordinate.x)+6)
          .attr('y', d=> linearScaleY(d.coordinate.y)+6)
          .on("click",d=> tomasz1(d));
 node.append("title")
    .data(nodes)
      .text(d=> d.name);
  // Let's list the force we wanna apply on the network

  // This function is run at each iteration of the force algorithm, updating the nodes position.
 

});

        
    </script>
}
